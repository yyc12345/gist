# 开发帮助

BMERevenge是内置于BallanceBlenderPlugin内的一套路面生成器（原本之前打算做新的2D编辑器，后来放弃了，改为直接Blender内生成）。  
此文档是BMERevenge开发中遵守的一些规定。此文档是第二版BMERevenge所用的标准，对应于BallanceBlenderPlugin 4.0及后续版本。

## 坐标系

* 坐标系系统使用Blender的右手坐标系。
* UV系统使用右手坐标系，具体参考后图。
* 面片支持N边形（N至少为3），其中以四边形和三角形面片的使用最为常见。面片的顶点序使用右手定则确定正面指向（OpenGL默认用右手坐标系，默认用右手定则确认正面；DirectX默认用左手坐标系，默认用左手定则确认正面）。

```
Blender coordinate system

                  +Z

                   X
                   X
                   X
                   X
                   X
                   X
                   X
                   X
                   X
                   X
                   XXXXXXXXXXXXXXXXXXXXXXXXX
                 XX                          +Y
               XXX
              XX
             XX
           XXX
          XX
        XXX
       XX
      XX
      X

+X

```

```
     +-----------------------------+
+V   |                             |
     | Image                       |
 ^   |                             |
 |   |                             |
 |   |                             |
 |   |                             |
 |   |                             |
 |   |                             |
 |   |                             |
 |   |                             |
 |   |                             |
 |   +-----------------------------+
 |
 +----------------------->  +U

 UV coordinate system

```

## 常用数据

* 贴图边框的条纹宽16像素（换算成UV为0.125）
* 下沉路面下沉0.7单位，对应的贴图减少到0.86（减少0.14）

## 原型

原型（Prototype）描述了一个组件是如何被顶点和面片组合而成的，是BMERevenge中的基础构建单元。BMERevenge中的所有结构都是由一个个原型组合而成的。  
原型使用JSON文本进行描述。下面是一个原型的描述的示例：

```json
{
    "identifier": "test",
    "showcase": {
        "title": "Test Block",
        "icon": "Flat",
    },
    "params": [
        {
            "field": "length",
            "type": "float",
            "title": "Length",
            "desc": "The size of block.",
            "default": 5.0
        },
        {
            "field": "count",
            "type": "int",
            "title": "Count",
            "desc": "Some count of this block.",
            "default": 0
        },
        {
            "field": "has_side",
            "type": "bool",
            "title": "Has Side",
            "desc": "Whether has xxx side.",
            "default": true
        }
    ],
    "vars": [
        {
            "field": "radius",
            "data": "length / 2"
        },
        {
            "field": "half_count",
            "data": "count // 2"
        },
        {
            "field": "use_long_side",
            "data": "not has_side"
        }
    ],
    "vertices": [
        {
            "skip": "False",
            "data": "(0, 0, 0)",
        },
        {
            "skip": "has_side",
            "data": "(2.5 + radius, 0, 0)",
        },
        {
            "skip": "use_long_side",
            "data": "(2.5 + length, sin(half_count * pi * 2), 0)",
        },
        {
            "skip": "False",
            "data": "(0, 2.5 if use_long_side else 5.0, 0)",
        }
    ],
    "faces": [
        {
            "skip": "use_long_side",
            "texture": "FloorTopBorderless",
            "indices": [0, 1, 2, 3],
            "uvs": [
                "(0, 0.5)",
                "(0, 0)",
                "(0.5, 0 + radius * 5)",
                "(0.5, 0.5)"
            ],
            "normals": [
                "(1, 0, 0)",
                "(1, 0, 0)",
                "(1, 0, 0)",
                "(1, 0, 0)"
            ]
        },
        {
            "skip": "not use_long_side",
            "texture": "FloorTopBorderless_ForSide",
            "indices": [3, 2, 1, 0],
            "uvs": [
                "(0, 0.5)",
                "(0, 0)",
                "(0.5, 0 + radius * 5)",
                "(0.5, 0.5)"
            ],
            "normals": [
                "(1, 0, 0)",
                "(1, 0, 0)",
                "(1, 0, 0)",
                "(1, 0, 0)"
            ]
        },
    ],
    "instances": [
        {
            "identifier": "another_test",
            "skip": "not use_long_side",
            "params": {
                "arg1": "not use_long_side",
                "arg2": "length != 0"
            },
            "transform": "move(2.5, 2.5, 0) @ rot(0, 0, 90)"
        },
        {
            "identifier": "another_test",
            "skip": "not use_long_side",
            "params": {
                "arg1": "not use_long_side",
                "arg2": "length != 0"
            },
            "transform": "move(-2.5, -2.5, 0) @ rot(0, 0, -90)"
        }
    ]
}
```

### 可编程字段

BMERevenge使用可编程字段来使得模型可以按照用户需要的大小与需求，在尽可能减少多边形数量的情况下进行构建。  
可编程字段在底层使用Python的`eval`函数进行计算。可编程字段可以使用大多数的Python语法内容，但只能使用受限的函数，以及一些只读变量的访问。  
原型中的许多字段均是可编程字段。可编程字段必须返回一个值，这个值的类型由具体的可编程字段指定。有的必须要返回元组，有的必须要返回bool等。在后文中如果某个字段是可编程字段，会显示指出，否则为普通的字段。可编程字段在JSON中永远是字符串形式，以用于Python中`eval`函数进行执行。

下表列出了可编程字段中提供的只读变量：

* 参数字段中指定的变量名：由参数字段决定的有限的只读变量的引用。
* 变量字段中指定的变量名：由变量字段决定的有限的只读变量的引用。请注意，在计算变量时不会提供这些。
* `math`模块中的常量
  - `pi`：圆周率
  - `tau`：二倍圆周率

下表列出了可编程字段中提供的函数：

* `math`模块中的以下函数
  - `sin cos tan asin acos atan`：三角函数和反三角函数
  - `pow sqrt`：幂函数
  - `fabs`：浮点绝对值
* 标准模块的以下函数
  - `abs`：绝对值函数
  - `int float str bool`：整数，浮点，字符串，布尔强制转换函数
* 一些自定义矩阵生成函数（返回`mathutils.Matrix`）
  - `move(x, y, z)`：构建一个移动矩阵，表示将这个物体在xyz上移动指定距离
  - `rot(x, y, z)`：构建一个旋转矩阵，表示将这个物体按照XYZ的欧拉角顺序各自旋转xyz度。xyz的度数以角度值（不是弧度值）提供。

下面列出了一些在可编程字段中常用的Python语法

* `()`：括号，强制结合。
* `+-*/`：四则运算，优先级与数学一致。
* `//`：整除运算
* `@`：可用于`mathutils.Matrix`矩阵之间的乘法。
* 立即数：即显式指定的浮点数或整数等数据。

### 标识符

标识符（`identifier`字段）表示了当前原型的全局唯一名称。该名称不得重复定义。

### 展示与模板

展示（`showcase`字段）表示了当前原型显示在插件创建菜单里所需要的数据。  
其中标题（`title`字段）表示了其显示的名称。图标（`icon`字段）决定了图标。这些图标被存储在专用的图标文件夹内。图标字段的值为对应图标的文件名部分（去除后缀名）。  

原型有模板与非模板之分。只有非模板的原型才会被显示在插件的创建菜单中。模板原型不会被显示，他们只能作为其它原型的基础组件被引用来进行使用。  
由于只有非模板原型才会被显示，因此也只有非模板原型才需要展示字段。所以展示字段的另一个功能是用来区分模板与非模板原型。当展示字段为`null`时，表示这是一个模板原型。否则其应当为一个非模板原型并具有上述结构。

### 参数

参数（`params`字段）定义了当前原型接受的参数，与函数调用中的参数类似，其决定了这个原型内的一些重要尺寸与结构。

参数字段是一个列表，列表中每一项定义一个参数。参数定义由以下几个方面组成：

* `field`：参数名称。不得重复定义。也不建议起任何常用函数名或Python保留字。
* `type`：参数类型。只能是float, int, bool其中之一。
* `title`：参数显示名称。参数在插件创建界面显示的名称。
* `desc`：参数解释。参数在插件创建界面触碰时显示的提示说明文本。
* `default`：参数的默认值。默认值类型由参数类型决定。

当从插件创建界面接受用户输入时，根据参数类型，参数数值具有一些约束。这些约束是：

* float：总是不小于0
* int：总是不小于0
* bool：只能为true或false

需要注意的是，当从`instances`调用子原型，设定参数并传递时则没有这些约束。这些约束只是由于用户界面的设定而被约束的。即约束只对顶级原型的参数有效。

### 变量

变量（`vars`字段）定义了当前原型所需要用到的一些额外数据。有些时候原型的创建中需要频繁用到某一项组合计算数值，那么可以将其独立成变量，先行计算，再在后续内容中引用它即可。  
变量没有参数中的类型限定要求，即不一定要是是float, int, bool其中之一，所以理论上它可以是任何Python类型，甚至可以是一个lambda表达式。但就使用情景而言，通常来说，它是float, int, bool其中之一。  
你不能起一个和参数同名的变量。一个名称在变量和参数中是唯一的。
请注意，虽然名义上是变量，但其实际上是常量。其数值在参数传入后计算，并且不可以在可编程字段中更改。

变量字段是一个列表，列表中每一项定义一个变量。与参数列表类似。

* `field`：参数名称。不得重复定义。
* `data`：一个可编程字段，返回计算得到的参数值。

### 顶点

顶点（`vertices`字段）定义了当前原型的网格顶点数据。  
顶点字段是一个列表，列表中每一项定义一个顶点。顶点定义由以下几个方面组成：

* `skip`：一个可编程字段，返回bool。指示当前顶点是否需要跳过，返回true即跳过这个顶点的创建。
* `data`：一个可编程字段，返回`tuple[float, float, float]`。表示这个顶点的位置。

当一个顶点被跳过的时候，它将不会出现在顶点列表中，也不会被分配任何顶点序号，后续的顶点会取代当前被跳过顶点的序号位置。在后续面数据对顶点序的引用中需要格外注意这一点。  
顶点和面的跳过通常用于一些特殊的分支创建场合。例如对于Ballance路面侧面，大于5的高度需要创建6个顶点，用2个面描述。而小于5的高度则只需要4个顶点和1个面来描述。通过合理使用skip字段和变量定义，可以实现所谓的分支构建。

### 面

面（`faces`字段）定义了当前原型的网格面数据。
面字段是一个列表，列表里每一项定义一个面。面定义由以下几个方面组成：

* `skip`：一个可编程字段，返回bool。指示当前面是否需要跳过，返回true即跳过这个面的创建。
* `texture`：指示当前面可用的材质，这些材质的名称被硬编码在插件中。
* `indices`：一个int列表，指定构建这个面的定点序。同时其大小N也表示了这个面是N边形。
* `uvs`：一个长度与`indices`相等列表，其中每一项都是一个可编程字段，返回`tuple[float, float]`。指示在这个面中，对应顶点的UV数据。
* `normals`：一个长度与`indices`相等列表，其中每一项都是一个可编程字段，返回`tuple[float, float, float]`。指示在这个面中，对应顶点的法向数据。此法向数据不需要归一化，插件在调用时会自动归一化，以方便一些计算。

当一个面被跳过时，其指定的材质若无其它使用则不会被添加到物体。

### 实例

实例（`instances`字段）定义了当前原型所引用的子原型。可以通过多个子原型来拼接得到一个大原型。

* `identifier`：表示该实例将要使用的子原型的标识符。
* `skip`：一个可编程字段，返回bool。指示当前实例是否需要跳过，返回true即跳过这个实例的创建。
* `params`：一个字典。字典的键为子原型对应形参的名称，键为一个可编程字段，返回的类型为子原型对应形参所需的类型。该字典需要指定子原型中`params`字段中所写的所有形参的实参。
* `transform`：一个可编程字段，返回`mathutils.Matrix`，一个4x4的矩阵。该矩阵指定了子原型的变换矩阵。

当前原型调用子原型时，不存在编程语言中的生命周期概念，即子原型不会读取到父原型中的任何参数。所有必要的参数都必须通过`params`字典给定的实参传递到子原型的形参中去。  
当向子原型应用变换矩阵时，首先对所有顶点参数应用此矩阵，同时面参数中的法向参数也会被此矩阵处理。传递给子原型的子原型的`transform`也会被先左乘上子原型的变换矩阵再传递。  
当实例被跳过时，实例项中的`params`和`transform`不会被计算。

## 构建

构建从用户选取的原型开始。首先获取用户输入。这些输入是被钳制在一定范围内的，然后将其输入用户选取的原型，即顶层原型。  
然后根据参数计算原型的变量字段。获取执行所需要的全部数据。  
然后根据顶点和面字段，按需求创建顶点和面。  
如果实例字段有指定，则计算传递给实例的参数，并递归调用本过程，继续为当前Mesh添加数据，直到顶层原型的所有实例创建完毕。
