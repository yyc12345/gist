# 开发帮助

BMERevenge是内置于BallanceBlenderPlugin内的一套路面生成器（原本之前打算做新的2D编辑器，后来放弃了，改为直接Blender内生成）。  
此文档是BMERevenge开发中遵守的一些规定。此文档是第二版BMERevenge所用的标准，对应于BallanceBlenderPlugin 4.0及后续版本。

## 坐标系

* 坐标系系统使用Blender的右手坐标系。
* UV系统使用右手坐标系，具体参考后图。
* 面片支持N边形（N至少为3），其中以四边形和三角形面片的使用最为常见。面片的顶点序使用右手定则确定正面指向（OpenGL默认用右手坐标系，默认用右手定则确认正面；DirectX默认用左手坐标系，默认用左手定则确认正面）。

```
Blender coordinate system

                  +Z

                   X
                   X
                   X
                   X
                   X
                   X
                   X
                   X
                   X
                   X
                   XXXXXXXXXXXXXXXXXXXXXXXXX
                 XX                          +Y
               XXX
              XX
             XX
           XXX
          XX
        XXX
       XX
      XX
      X

+X

```

```
 UV coordinate system

     +-----------------------------+
+V   |                             |
     | Image                       |
 ^   |                             |
 |   |                             |
 |   |                             |
 |   |                             |
 |   |                             |
 |   |                             |
 |   |                             |
 |   |                             |
 |   |                             |
 |   +-----------------------------+
 |
 +----------------------->  +U

```

## 常用数据与术语

* 贴图边框的条纹宽16像素（换算成UV为0.125）
* 下沉路面下沉0.7单位，对应的贴图减少到0.86（减少0.14）
* 对于一个在上述坐标系中的立方体，我们称+Z方向的面为顶面（top face），-Z方向的面为底面（bottom face），-X方向的面为前面（front face），+X方向的面为后面（back face），-Y方向的面为左面（left face），+Y方向的面为右面（right face）

## 原型

原型（Prototype）描述了一个组件是如何被顶点和面片组合而成的，是BMERevenge中的基础构建单元。BMERevenge中的所有结构都是由一个个原型组合而成的。  
原型使用JSON文本进行描述。下面是一个原型的描述的示例：

```json
{
    "identifier": "test",
    "showcase": {
        "title": "Test Block",
        "icon": "Flat",
        "type": "floor",
        "cfgs": [
            {
                "field": "length_",
                "type": "float",
                "title": "Length",
                "desc": "The size of block.",
                "default": "5.0"
            },
            {
                "field": "count_",
                "type": "int",
                "title": "Count",
                "desc": "Some count of this block.",
                "default": "0"
            },
            {
                "field": "has_side_",
                "type": "bool",
                "title": "Has Side",
                "desc": "Whether has xxx side.",
                "default": "True"
            }
        ]
    },
    "params": [
        {
            "field": "length",
            "data": "length_"
        },
        {
            "field": "count",
            "data": "count_"
        },
        {
            "field": "has_side",
            "data": "has_side_"
        }
    ],
    "skip": "length == 0.0",
    "vars": [
        {
            "field": "radius",
            "data": "length / 2"
        },
        {
            "field": "half_count",
            "data": "count // 2"
        },
        {
            "field": "use_long_side",
            "data": "not has_side"
        }
    ],
    "vertices": [
        {
            "skip": "False",
            "data": "(0, 0, 0)",
        },
        {
            "skip": "has_side",
            "data": "(2.5 + radius, 0, 0)",
        },
        {
            "skip": "use_long_side",
            "data": "(2.5 + length, sin(half_count * pi * 2), 0)",
        },
        {
            "skip": "False",
            "data": "(0, 2.5 if use_long_side else 5.0, 0)",
        }
    ],
    "faces": [
        {
            "skip": "use_long_side",
            "texture": "\"FloorTopBorderless\"",
            "indices": [0, 1, 2, 3],
            "uvs": [
                "(0, 0.5)",
                "(0, 0)",
                "(0.5, 0 + radius * 5)",
                "(0.5, 0.5)"
            ],
            "normals": [
                "(1, 0, 0)",
                "(1, 0, 0)",
                "(1, 0, 0)",
                "(1, 0, 0)"
            ]
        },
        {
            "skip": "not use_long_side",
            "texture": "\"FloorTopBorderless_ForSide\"",
            "indices": [3, 2, 1, 0],
            "uvs": [
                "(0, 0.5)",
                "(0, 0)",
                "(0.5, 0 + radius * 5)",
                "(0.5, 0.5)"
            ],
            "normals": [
                "(1, 0, 0)",
                "(1, 0, 0)",
                "(1, 0, 0)",
                "(1, 0, 0)"
            ]
        },
    ],
    "instances": [
        {
            "identifier": "another_test",
            "skip": "not use_long_side",
            "params": {
                "arg1": "not use_long_side",
                "arg2": "length != 0"
            },
            "transform": "move(2.5, 2.5, 0) @ rot(0, 0, 90)"
        },
        {
            "identifier": "another_test",
            "skip": "not use_long_side",
            "params": {
                "arg1": "not use_long_side",
                "arg2": "length != 0"
            },
            "transform": "move(-2.5, -2.5, 0) @ rot(0, 0, -90)"
        }
    ]
}
```

### 可编程字段

BMERevenge使用可编程字段来使得模型可以按照用户需要的大小与需求，在尽可能减少多边形数量的情况下进行构建。  
可编程字段在底层使用Python的`eval`函数进行计算。可编程字段可以使用大多数的Python语法内容，但只能使用受限的函数，以及一些只读变量的访问。  
原型中的许多字段均是可编程字段。可编程字段必须返回一个值，这个值的类型由具体的可编程字段指定。有的必须要返回元组，有的必须要返回bool等。在后文中如果某个字段是可编程字段，会显示指出，否则为普通的字段。可编程字段在JSON中永远是字符串形式，以用于Python中`eval`函数进行执行。

下表列出了可编程字段中提供的只读变量，根据字段的不同，我们提供不同的变量访问：

* 总是提供以下常量：
  - `math`模块中的常量
    * `pi`：圆周率
    * `tau`：二倍圆周率
* 计算参数字段时：
  - 如果当前原型是顶级原型：提供只读的用户输入的设定字段。
  - 否则：直接从子原型实例化中获取参数字段的实参值，而不是计算参数字段。
* 计算变量字段时：提供只读的参数字段中的变量。
* 计算其它字段时：提供只读的参数字段和变量字段中的变量。

下表列出了可编程字段中提供的函数：

* `math`模块中的以下函数
  - `sin`, `cos`, `tan`, `asin`, `acos`, `atan`：三角函数和反三角函数
  - `pow`, `sqrt`：幂函数
  - `fabs`：浮点绝对值
  - `degrees`, `radians`：角度与弧度转换函数
* 标准模块的以下函数
  - `abs`：绝对值函数
  - `int`, `float`, `str`, `bool`：整数，浮点，字符串，布尔强制转换函数
* 一些自定义矩阵生成函数（返回`mathutils.Matrix`）
  - `move(x, y, z)`：构建一个移动矩阵，表示将这个物体在xyz上移动指定距离
  - `rot(x, y, z)`：构建一个旋转矩阵，表示将这个物体按照XYZ的欧拉角顺序各自旋转xyz度。xyz的度数以角度值（不是弧度值）提供。
  - `scale(x, y, z)`：构建一个缩放矩阵，表示将这个物体在XYZ轴上分别被缩放大小。请注意保持缩放不变需要给定1，而不是0。
  - `ident()`：构建一个没有任何变换的矩阵。
* 一些自定义函数
  - `distance(x1, y1, x2, y2)`：计算给定两点间的欧几里得距离
  - `angle(x1, y1, x2, y2)`：以第一个点为原点，计算第二个点相对于第一个点转过了多少角度。0度为+X轴；从+Z轴向-Z轴看去，逆时针方向为正向；取值范围为0-360度；返回值是角度值，而非弧度值。

下面列出了一些在可编程字段中常用的Python语法

* `()`：括号，强制结合。
* `+-*/`：四则运算，优先级与数学一致。
* `//`：整除运算
* `**`：幂运算
* `@`：可用于`mathutils.Matrix`矩阵之间的乘法。
* 立即数：即显式指定的浮点数或整数等数据。

### 标识符

标识符（`identifier`字段）表示了当前原型的全局唯一名称。该名称不得重复定义。

### 展示与模板

展示（`showcase`字段）表示了当前原型显示在插件创建菜单里所需要的数据。  
其中标题（`title`字段）表示了其显示的名称。图标（`icon`字段）决定了图标。这些图标被存储在专用的图标文件夹内。图标字段的值为对应图标的文件名部分（去除后缀名）。

类型（`type`字段）是一个字符串，决定了当前原型最终生成的是何种类型的Ballance机关。类型决定了生成的物体将会以何种格式命名，以及被归入哪些Virtools组中。类型字段仅支持以下内容：

* `none`：装饰类
* `floor`：路面
* `rail`：钢轨
* `wood`：木板

而设定（`cfgs`字段）描述了当前原型展示时由用户输入的参数设定。设定字段是一个列表，列表中每一项定义一个设定。设定定义由以下几个方面组成：

* `field`：设定名称。不得重复定义。也不建议起任何常用函数名或Python保留字。
* `type`：设定类型。只能是`float`, `int`, `bool`, `face`其中之一。
* `title`：设定显示名称。设定在插件创建界面显示的名称。
* `desc`：设定解释。设定在插件创建界面触碰时显示的提示说明文本。
* `default`：一个可编程字段，返回设定的默认值。返回的默认值类型由设定类型决定。

其中`face`类型用于表征物体6个面是否显示，是一个具有6个bool元素的元组，分别指代这些面的显示与否：`(top, bottom, front, back, left, right)`。

当从插件创建界面接受用户输入时，根据设定类型，设定数值具有一些约束。这些约束是：

* `float`：总是不小于0
* `int`：总是不小于0
* `bool`：只能为true或false
* `face`：总是一个具有6个bool元素的元组。

原型有模板与非模板之分。只有非模板的原型才会被显示在插件的创建菜单中。模板原型不会被显示，他们只能作为其它原型的基础组件被引用来进行使用。  
由于只有非模板原型才会被显示，因此也只有非模板原型才需要展示字段。所以展示字段的另一个功能是用来区分模板与非模板原型。当展示字段为`null`时，表示这是一个模板原型。否则其应当为一个非模板原型并具有上述结构。

您可能会注意到，我们有3种参数声明：设定字段，参数字段，变量字段。他们具有不同的功能。设定字段是服务于用户界面显示和输入的，对于模板原型而言，设定字段是不存在的。而参数字段则是真实传递给原型的生成数据，且当使用子原型指定参数的时候，指定的也是参数字段中的数据。最后，变量字段是为了减轻原型生成过程中的计算来用的。  
同时，设定字段，参数字段，变量字段中的每一项都具有一个唯一的名称，与编程语言相似，我们要求他们的名称在这三个部分中是唯一的。即不能在设定字段中出现`example`，又在参数字段中出现`example`。

### 参数

参数（`params`字段）定义了当前原型接受的参数，与函数调用中的参数类似，其决定了这个原型内的一些重要尺寸与结构。

参数字段是一个列表，列表中每一项定义一个参数。参数定义由以下几个方面组成：

* `field`：参数名称。不得重复定义。
* `data`：一个可编程字段，返回计算得到的参数值。

与设定字段不同，参数字段实际上是用于这个原型生成的真正数据。当前原型是顶级原型，即对外提供参数字段并获得了用户输入后，将执行可编程字段`data`以从获取到的参数字段中提炼出此原型使用的参数。而当此原型被作为子原型而调用时，不会执行可编程字段`data`的计算，转而使用子原型指定时的实参列表初始化所有参数字段。  
参数一旦计算或获取完毕后，在后续的计算的使用上均视为常量。

参数字段没有设定字段中的类型限定要求，即不一定要是`float`, `int`, `bool`, `face`（6个bool的元组）其中之一，所以理论上它可以是任何Python类型，甚至可以是一个lambda表达式。但就通常的使用情景而言来说，它是`float`, `int`, `bool`其中之一。

### 跳过

跳过（`skip`字段）定义了当前原型是否应该跳过生成。当跳过生成时，该字段后的所有内容均会被跳过，不会被引用或运算。

跳过字段是一个可编程字段，它总是需要返回一个bool值，返回true则表示跳过这个原型的创建。在运算这个可编程字段时，你可以获取到参数字段中定义的各类常量，这方便你检查这些参数是否符合要求，是否会导致接下来的计算出错。这就相当于你在检查一个函数的输入参数是否合法。

### 变量

变量（`vars`字段）定义了当前原型所需要用到的一些额外数据。有些时候原型的创建中需要频繁用到某一项组合计算数值，例如路面花边的高度，那么可以将其独立成变量，先行计算，再在后续内容中引用它即可。  
你不能起一个和参数同名的变量。一个名称在设定字段，参数字段，变量字段中需要是唯一的。  
与参数字段类似，变量字段也没有设定字段中的类型限定要求。  
请注意，虽然名义上是变量，但其实际上是常量。其数值在参数传入后计算，并且不可以在可编程字段中更改。

变量字段是一个列表，列表中每一项定义一个变量。与参数列表类似。

* `field`：参数名称。不得重复定义。
* `data`：一个可编程字段，返回计算得到的参数值。

### 顶点

顶点（`vertices`字段）定义了当前原型的网格顶点数据。  
顶点字段是一个列表，列表中每一项定义一个顶点。顶点定义由以下几个方面组成：

* `skip`：一个可编程字段，返回bool。指示当前顶点是否需要跳过，返回true即跳过这个顶点的创建。
* `data`：一个可编程字段，返回`tuple[float, float, float]`。表示这个顶点的位置。

当一个顶点被跳过的时候，它将不会出现在顶点列表中，也不会被分配任何顶点序号，后续的顶点会取代当前被跳过顶点的序号位置。在后续面数据对顶点序的引用中需要格外注意这一点。  
顶点和面的跳过通常用于一些特殊的分支创建场合。例如对于Ballance路面侧面，大于5的高度需要创建6个顶点，用2个面描述。而小于5的高度则只需要4个顶点和1个面来描述。通过合理使用skip字段和变量定义，可以实现所谓的条件构建。

### 面

面（`faces`字段）定义了当前原型的网格面数据。
面字段是一个列表，列表里每一项定义一个面。面定义由以下几个方面组成：

* `skip`：一个可编程字段，返回bool。指示当前面是否需要跳过，返回true即跳过这个面的创建。
* `texture`：一个可编程字段，返回str。指示当前面可用的材质，这些材质的名称被硬编码在插件中。
* `indices`：一个int列表，指定构建这个面的顶点序。同时其大小N也表示了这个面是N边形。
* `uvs`：一个长度与`indices`相等列表，其中每一项都是一个可编程字段，返回`tuple[float, float]`。指示在这个面中，对应顶点的UV数据。
* `normals`
  - 一个长度与`indices`相等列表，其中每一项都是一个可编程字段，返回`tuple[float, float, float]`。指示在这个面中，对应顶点的法向数据。此法向数据不需要归一化，插件在调用时会自动归一化，以方便一些计算。
  - 或null，表示这个面的法线数据将会从顶点数据自行计算，不需要手动指定。法线的正向由右手定则从顶点序中得到。

当一个面被跳过时，其指定的材质若无其它使用则不会被添加到物体。

### 实例

实例（`instances`字段）定义了当前原型所引用的子原型。可以通过多个子原型来拼接得到一个大原型。

* `identifier`：表示该实例将要使用的子原型的标识符。
* `skip`：一个可编程字段，返回bool。指示当前实例是否需要跳过，返回true即跳过这个实例的创建。
* `params`：一个字典。字典的键为子原型对应形参的名称。字典的值为一个可编程字段，没有返回值类型限制，只要子原型对应形参可接受即可。该字典需要指定子原型中`params`字段（请注意是参数字段，而不是设定字段）中所写的所有形参的实参。
* `transform`：一个可编程字段，返回`mathutils.Matrix`，一个4x4的矩阵。该矩阵指定了将被应用于子原型的变换矩阵，通常这被用于移动，旋转，缩放所构建的子原型实例，以让各个实例之间形成正确的组合体。

当前原型调用子原型时，不存在编程语言中的生命周期概念，即子原型不会读取到父原型中的任何参数。所有必要的参数都必须通过`params`字典给定的实参传递到子原型的形参中去。  
当向子原型应用变换矩阵时，首先对所有顶点参数应用此矩阵，同时面参数中的法向参数也会被此矩阵处理。传递给子原型的`transform`也会被先左乘上当前原型的变换矩阵再传递（子原型变换应用后再应用当前原型的变换，所以是左乘）。需要注意的是，越靠近表达式右侧的矩阵将先与坐标向量运算，因此需要注意运算顺序。  
当实例被跳过时，实例项中的`params`和`transform`不会被计算。

## 构建

1. 构建从用户选取的原型开始。首先在invoke函数中指定设定字段的默认值，然后在execute中获取用户输入。用户输入是被钳制在一定范围内的，然后将其输入用户选取的原型，即顶层原型。  
1. 然后根据参数计算原型的变量字段。获取执行所需要的全部数据。  
1. 然后根据顶点和面字段，按需求创建顶点和面。  
1. 如果实例字段有指定，则计算传递给实例的参数，并从第二步开始递归调用本过程，继续为当前Mesh添加数据，直到顶层原型的所有实例创建完毕。
